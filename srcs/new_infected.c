/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   new_infected.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: plamtenz <plamtenz@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/02/20 00:12:46 by plamtenz          #+#    #+#             */
/*   Updated: 2020/02/20 02:52:34 by plamtenz         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <bin_packer.h>

uint8_t payload[] =
{
	0x50, 0x57, 0x56, 0x52, 0x51, 0x41, 0x50, 0x41, 0x51, 0x41,
	0x52, 0xe8, 0x0c, 0x00, 0x00, 0x00, 0x2e, 0x2e, 0x2e, 0x57,
	0x4f, 0x4f, 0x44, 0x59, 0x2e, 0x2e, 0x2e, 0x0a, 0xbf, 0x01,
	0x00, 0x00, 0x00, 0x5e, 0xba, 0x0c, 0x00, 0x00, 0x00, 0xb8,
	0x01, 0x00, 0x00, 0x00, 0x0f, 0x05, 0xe8, 0x09, 0x00, 0x00,
	0x00, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x00,
	0x5f, 0xc6, 0x07, 0x2a, 0xc6, 0x47, 0x01, 0x2a, 0xc6, 0x47,
	0x02, 0x2a, 0xc6, 0x47, 0x03, 0x2a, 0xc6, 0x47, 0x04, 0x2a,
	0xc6, 0x47, 0x05, 0x2a, 0xc6, 0x47, 0x06, 0x2a, 0xc6, 0x47,
	0x07, 0x2a, 0xbe, 0x08, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x15,
	0x98, 0xff, 0xff, 0xff, 0xb9, 0x42, 0x00, 0x00, 0x00, 0xe8,
	0x05, 0x00, 0x00, 0x00, 0xe9, 0xef, 0x00, 0x00, 0x00, 0x55,
	0x48, 0x89, 0xe5, 0x48, 0x81, 0xec, 0x88, 0x01, 0x00, 0x00,
	0x49, 0x89, 0xd1, 0x41, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x46,
	0x88, 0x84, 0x04, 0x88, 0x00, 0x00, 0x00, 0x44, 0x89, 0xc0,
	0x99, 0xf7, 0xfe, 0x48, 0x63, 0xd2, 0x0f, 0xb6, 0x04, 0x17,
	0x42, 0x88, 0x44, 0x04, 0x88, 0x49, 0x83, 0xc0, 0x01, 0x49,
	0x81, 0xf8, 0x00, 0x01, 0x00, 0x00, 0x75, 0xd9, 0xba, 0x00,
	0x00, 0x00, 0x00, 0xbe, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x8d,
	0x44, 0x24, 0x88, 0x0f, 0xb6, 0xbc, 0x14, 0x88, 0x00, 0x00,
	0x00, 0x40, 0x0f, 0xb6, 0xc7, 0x01, 0xf0, 0x42, 0x0f, 0xb6,
	0x34, 0x02, 0x01, 0xf0, 0x89, 0xc6, 0xc1, 0xfe, 0x1f, 0xc1,
	0xee, 0x18, 0x01, 0xf0, 0x0f, 0xb6, 0xc0, 0x29, 0xf0, 0x89,
	0xc6, 0x48, 0x98, 0x44, 0x0f, 0xb6, 0x94, 0x04, 0x88, 0x00,
	0x00, 0x00, 0x44, 0x88, 0x94, 0x14, 0x88, 0x00, 0x00, 0x00,
	0x40, 0x88, 0xbc, 0x04, 0x88, 0x00, 0x00, 0x00, 0x48, 0x83,
	0xc2, 0x01, 0x48, 0x81, 0xfa, 0x00, 0x01, 0x00, 0x00, 0x75,
	0xb2, 0x85, 0xc9, 0x7e, 0x4a, 0x8d, 0x41, 0xff, 0x49, 0x8d,
	0x7c, 0x01, 0x01, 0x31, 0xd2, 0x31, 0xc0, 0x48, 0x83, 0xc0,
	0x01, 0x0f, 0xb6, 0xc0, 0x0f, 0xb6, 0x8c, 0x04, 0x88, 0x00,
	0x00, 0x00, 0x01, 0xca, 0x0f, 0xb6, 0xd2, 0x0f, 0xb6, 0xb4,
	0x14, 0x88, 0x00, 0x00, 0x00, 0x40, 0x88, 0xb4, 0x04, 0x88,
	0x00, 0x00, 0x00, 0x88, 0x8c, 0x14, 0x88, 0x00, 0x00, 0x00,
	0x02, 0x8c, 0x04, 0x88, 0x00, 0x00, 0x00, 0x41, 0x30, 0x09,
	0x49, 0x83, 0xc1, 0x01, 0x4c, 0x39, 0xcf, 0x75, 0xc2, 0x48,
	0x81, 0xc4, 0x88, 0x01, 0x00, 0x00, 0xc9, 0xc3, 0x41, 0x5a,
	0x41, 0x59, 0x41, 0x58, 0x59, 0x5a, 0x5e, 0x5f, 0x58, 0xe9,
	0xba, 0xba, 0xfe, 0xca
};

static void             init_payload(t_packer *pack, t_elf64 *data)
{
    size_t              offset;
    register size_t     it;
    const Elf64_Addr    entry = endian_64bits(data->original_entry - (data->segment.phdr_addr
            + data->segment.phdr_filesz) - PAYLOAD_SIZE);
    const Elf64_Off     text_entry = endian_64bits(entry + (PAYLOAD_SIZE - 100 - 4));
    const Elf64_Off     limit = endian_64bits(data->section.shdr_filesz - (data->original_entry
            - data->section.shdr_addr));

    offset = 64;
    it = -1;
    memcpy(&payload[100], &text_entry, sizeof(int));
    memcpy(&payload[105], &limit, sizeof(int));
    while (++it < SECRET_SIZE)
    {
        payload[offset - 1] = pack->key[it];
        offset += 4;
    }
    memcpy(&payload[PAYLOAD_SIZE - sizeof(int)], &entry, sizeof(int));
}

static void             insert_payload(size_t *offset, const Elf64_Off size,
        bool align, char **dest, char *src)
{
    while (!align && *offset < size)
    {
        *(*dest)++ = *src++;
        *offset++;
    }
    while (align && *offset < size)
    {
        *(*dest)++ = 0;
        *offset++;
    }
}

static void             setup_payload(t_packer *pack, t_packer *infected, t_elf64 *data)
{
    size_t              offset;
    char                *src;
    char                *dest;
    const Elf64_Off     encrypt_start = endian_64bits(data->section.shdr_off + (data->original_entry - data->section.shdr_addr));
    const Elf64_Off     encrypt_end = endian_64bits(data->section.shdr_off + data->section.shdr_filesz);
    const Elf64_Off     payload_start = endian_64bits(data->segment.phdr_off + data->segment.shdr_filesz);
    const Elf64_Off     payload_end = endian_64bits(data->segment.phdr_off + data->segment.shdr_filesz + PAGE_SIZE);
    const Elf64_Off     eof = endian(pack->size + PAGE_SIZE);

    offset = 0;
    src = pack->map;
    dest = infected->map;
    insert_payload(&offset, encrypt_start, false, &dest, src);
    insert_payload(&offset, encrypt_end, false, &dest, src);
    insert_payload(&offset, payload_start, false, &dest, src);
    insert_payload(&offset, payload_end, true, &dest, src);
    insert_payload(&offset, eof, false, &dest, src);
    memcpy(infected->map + payload_start, payload, PAYLOAD_SIZE);
    encrypt();
    if (write(infected->fd, infected->map, eof) < (size_t)eof)
        error(ERR_CORUPT, "can't write into packed binaty\n")
}

void                    create_infected_elf_x64(t_packer *pack, t_elf64 *data)
{
    t_packer            infected;

    if ((infected.fd = open(OUTPUT_NAME, O_RDWR | O_CREAT | O_TRUNC, 0700)) < 0)
        error(ERR_SYS, "Can't open the clone file\n");
    if ((infected.map = mmap(0, pack->size + PAGE_SIZE, PROT_READ | PROT_WRITE,
            MAP_PRIVATE | MAP_ANON, -1, 0)) == MAP_FAILED)
    {
        close(infected.fd);
        error(ERR_SYS, "mmap() failed in new_infected.c\n");
    }
    init_payload(pack, data);
    setup_payload(pack, &infected, data);
    if (close(infected.fd) < 0)
        error(ERR_SYS, "can't no close the fd of the clone\n");
    if (munmap(infected.map, pack->size + PAGE_SIZE))
        error(ERR_SYS, "munmap failed in new_infected.c\n");
}